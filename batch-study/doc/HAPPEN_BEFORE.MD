##  什么是happens-before  
happens-before” 是 Java 内存模型（Java Memory Model, JMM） 中的一个核心概念，它是 Java 保证多线程间可见性和有序性的理论基础。

一、它属于什么？  
- 属于：Java Memory Model（JMM）    
- 实现依赖：JVM 与硬件（CPU、缓存一致性、内存屏障等）  
- 不属于 Java 语言语法，也不是 JVM 独立规范，而是 JMM 的核心语义规则，用来定义“一个操作的结果对另一个操作可见”的前提。  
---  
🧠 二、为什么需要 happens-before？
- 在多线程环境下，CPU 出于性能考虑可能会：
  - 乱序执行指令
  - 缓存变量而不写回主内存
  - 导致某些线程看到的是旧数据或未初始化状态
  - 为了解决这些“看不见”或“乱顺序”的问题，Java 定义了“happens-before 关系”，用来判断：
  - 一个操作是否对另一个操作可见？执行顺序是否有保障？  
## 、happens-before 的八大规则（JMM定义）
| 规则编号 | happens-before 规则 | 通俗解释                                                             |
| ---- | ----------------- | ---------------------------------------------------------------- |
| 1    | 程序顺序规则            | 同一个线程中，前面的操作 happens-before 后面的操作                                |
| 2    | 监视器锁规则            | 一个解锁 unlock 发生在后面对同一锁的加锁 lock 之前                                 |
| 3    | volatile 规则       | 对 volatile 变量的写操作 happens-before 后续的读操作                          |
| 4    | 线程启动规则            | `Thread.start()` 之前的操作，对新线程可见                                    |
| 5    | 线程终止规则            | 一个线程的所有操作 happens-before `Thread.join()` 返回                      |
| 6    | 线程中断规则            | 对线程 `interrupt()` 调用 happens-before 线程检测到中断                      |
| 7    | 对象构造规则            | 构造函数中的操作，对构造完成的对象可见（前提：this 没逸出）                                 |
| 8    | 传递性               | 如果 A happens-before B，且 B happens-before C，那么 A happens-before C |  
### 程序顺序规则
```java
int a = 1;       // 先执行
int b = a + 1;   // 后执行，且能看到 a = 1
```  
- 保证线程内 代码语义一致性  
---  
- 2️⃣ 监视器锁规则（synchronized）
```java
synchronized (lock) {
sharedVar = 100; // 线程A写
        }
// ------
synchronized (lock) {
        System.out.println(sharedVar); // 线程B读
}
```
✅ 线程A释放锁后，线程B获取同一把锁，能 看到 A 对共享变量的修改。
**✅ 线程A释放锁后，线程B获取同一把锁，能看到 A 对共享变量的修改。**  
---  
### volatile 变量规则  
```java
volatile boolean flag = false;

// 线程1
flag = true;

// 线程2
if (flag) {
    // 能看到线程1的修改
}

```
✅ 对 volatile 变量的写，对后续读可见。  
⚠️ 只保证 可见性 和 禁止重排序，不保证原子性。  
---  

###  线程启动规则  
```java
int a = 1;
Thread t = new Thread(() -> {
    System.out.println(a); // ✅ 能看到主线程中设置的 a=1
});
t.start();

```
**✅ 主线程在 start() 前的操作，对子线程可见。**  
---  
  
### 线程终止规则  
```java
Thread t = new Thread(() -> {
    result = compute(); // 线程写变量
});
t.start();
t.join(); // 阻塞等待线程完成
System.out.println(result); // ✅ 线程t的写对主线程可见  
```  
join() 保证子线程操作对主线程可见。**

---  
### 中断规则  
```java
// 线程A
t.interrupt();

// 线程B
if (Thread.currentThread().isInterrupted()) {
    // ✅ 能检测到中断
}

```  
**✅ interrupt 的调用对目标线程检测中断可见。**

---

### 构造规则（Construction Rule）是 Java Memory Model（JMM）中 **happens-before** 的第 7 条规则，意思是：  
这里和**final**关键字关系很大,一个变量就是让变量在构造器方法中必定比this赋值

> ✅ **一个对象的构造方法中的所有写操作，happens-before 其他线程获取该对象引用后的读操作。**

换句话说：

🧠 通俗解释：

当你在一个线程中用 `new` 构造一个对象，并把这个对象发布（赋值）给其他线程时：

* **只要对象构造“没有发生 this 逃逸”**，
* 那么构造方法里写入的所有字段值，**其他线程都能看到最新的值**。

📦 举个例子（✅ 正确）

```java
class Person {
    int age;

    Person() {
        age = 18; // 初始化
    }
}

public class Demo {
    static Person person;

    public static void main(String[] args) throws Exception {
        Thread t1 = new Thread(() -> {
            person = new Person();  // 对象构造完后赋值
        });

        Thread t2 = new Thread(() -> {
            while (person == null); // 等待构造完成
            System.out.println(person.age); // 这里能看到 18
        });

        t1.start();
        t2.start();
    }
}
```

✅ 虽然是两个线程，但 `t2` 中读取 `person.age` 一定能看到构造方法里设的 `18`，因为 `构造方法的写 → 获取引用的读` 是一个 happens-before。


⚠️ 错误例子：this 逸出（构造过程未完成就发布）

```java
class Bad {
    static Bad instance;
    int num;

    public Bad() {
        instance = this; // ❌ this 逃逸
        num = 42;        // 后执行
    }
}
```

假如另一个线程通过 `Bad.instance` 获取对象，由于 `this` 提前暴露，线程可能会：

* 拿到一个构造还没执行完的对象；
* 看到 `num = 0` 而不是 `42`；
* 导致 “半初始化” 状态（很危险）。

 ✅ 构造规则总结：

| 特点 | 描述                     |
| -- | ---------------------- |
| 所属 | happens-before 规则第 7 条 |
| 条件 | 对象不能在构造过程中“逸出”         |
| 意义 | 保证构造方法中的赋值对其他线程可见      |
| 应用 | 单例模式、安全发布对象            |


🔥 面试重点：构造规则 + 单例模式

在双重检查锁（DCL）中，你会看到：

```java
private static volatile Singleton instance;

public static Singleton getInstance() {
    if (instance == null) {
        synchronized (Singleton.class) {
            if (instance == null) {
                instance = new Singleton(); // 构造 + volatile 保证可见
            }
        }
    }
    return instance;
}
```

> ✅ 这里的 `volatile` 是为了配合构造规则防止半初始化，防止 CPU 指令重排。

---  
### 传递性
  A happens-before B，B happens-before C，则 A happens-before C。
  例如：
  - volatile write → volatile read → 普通读写
  - unlock → lock → 操作
  - ✅ 这使得多步骤同步成为可能。  
---



