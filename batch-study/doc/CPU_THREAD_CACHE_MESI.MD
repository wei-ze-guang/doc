### CPU和多线程之间的关系，注意线程是在操作系统层面的东西
1. 单核CPU 他永远是单线程运行的,比如时间片轮。可以实现多线程，一个CPU运行多个线程的话实现的是伪并发或者逻辑并发  
一个CPU 他永远在同一时刻只能实现一个线程工作，其他线程挂起
2. 多核(2个或者两个以上CPU) 这样能做到真的并行(和并发有点区别) 当然也能实现更高的伪并发，比如总的线程是比CPU数量多，那么肯定是并发和并发存在  

### 主存,CPU,CACHE(缓存的关系)
       【CPU 核心1】                             【CPU 核心2】
    ┌────────────────┐                     ┌────────────────┐
    │ Thread-A        │                     │ Thread-B        │
    │ 工作内存/工作区 │                     │ 工作内存/工作区 │
    └──────┬─────────┘                     └──────┬─────────┘
           │                                        │
       ┌───▼──────────────┐                    ┌───▼──────────────┐
       │   L1/L2 Cache     │◀────┐         ┌───▶│   L1/L2 Cache     │
       └────────┬──────────┘     │MESI 协议│     └────────┬──────────┘
                │                │维护一致│                │
             ┌──▼────────────────▼────────▼──┐
             │        L3 Cache（多核共享）      │  ⇦ MESI 协议也参与共享缓存一致性维护
             └───────────────────┬────────────┘
                                 │
                            ┌────▼─────┐
                            │  主存 RAM │  ⇦ 所有缓存最终都同步于此
                            └──────────┘


1. 主存(ARM) 一般设备只有一个，就把他想做一个就行
2. 每一个(注意是每一个核) 都有自己的L1/L2或者更多的缓存,他们的关系如上面
#### MESI缓存一致性原则 
1. 缓存核主存是按行调度的
2. CPU取数据顺序: 先看他所在的缓存有没有，有的话直接使用缓存数据，如果没有的话取主存找，找到之后先把数据调入缓存，这时候缓存就有数据了  
然后再从缓存取数据
3. CPU写内内容流程是这样的: 先更新他所在的核的缓存，再把数据写入主存
4. 每一个缓存L1/L2或者更多的还有L3 ，因为多个缓存共享一个主存，缓存里面存放的时候主存的副本，也就说主存数据改变，缓存就一定需要刷新  
当有一个核(CPU)对他他的缓存内部的数据做了操作，他会先把数据写回他自己的缓存，然后再写回内存，这时候问题来了，如果别的缓存存的就是刚刚
被写入的主存，就会导致别的CPU也就是别的核所在的缓存核主存数据不一样，这时候就违背了缓存一致性原则，为了解决这个问题，
 - 当主存刷新的时候，通过缓存监听，别的缓存的标志就会被标志位失效，那么当CPU读取数据的时候，他发现他所在的缓存失效了，这时候他就会执行  
上面的2 的取数据流程，也就是从主存读取，先把数据存入他的缓存，再从缓存读物数据，这样子就维持了缓存一致性  

#### 多线程下jvm模拟的线程内存 抽象模型  
多线程的工作内存模拟了现在设备的 内存，缓存空间，但是设备的缓存和主存之间是按行交换的，但是多线程下 数据调度可能并不是按行调度的  
我们只需要清楚线程内的变量的副本已经已经和主存发生变化，需要清空线程内缓存，就行。
