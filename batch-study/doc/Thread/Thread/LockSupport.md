## LockSupport类，再juc包下的工具包 
每个线程都有一个一个通行证，这个通行证是只有一个，他的数量只能是0或者1
### LockSupport.unPark(Thread t)，静态方法，是有参数的，使用这个方法的话那个线程的通行证结果一定是1
- 如果你使用LockSupport.unPark(Thread t)，他会先检查这个线程的通行证，如果是0，通行证设置为1，如果是1，那么最后也是1，也就是说，无论这个线程
被ockSupport(Thread t) 多少次，结果都是1，而且肯定会是1
- LockSupport.unPark(Thread t)
### LockSupport.park() 静态方法，没有参数，获取的就是当前线程的通行证 ,再使用这个方法的时候他会先检查这个线程通行证
- 如果线程的通行证数量是1，那么他会使用一张通行证，把通行证数量设置为0，然后直接返回不挂起  
- 如果线程通行证数量为0，那么他会立刻挂起来，并且不会去轮询这个通行证，他什么时候会被唤醒呢？  
  - 当别的线程使用LockSupport.unPark(Thread t)，这个t就是使用park（）被挂起的线程，JVM他会自己唤醒这个线程，这个线程就会唤醒，然后他会使用这个线程的通行证，最后通行证还是0，看下面
  - 初始：permit = 0
    - 调用 park() → 没有通行证 → 挂起
    - 其他线程调用 unpark(t) → permit = 1，并唤醒线程 t
    - 线程 t 被唤醒 → 在返回前内部会自动消耗 permit
    - 线程执行继续 → permit = 0  
### 方法使用顺序
- 先unPark() 后park()
1.  先unPark(Thread t),这时候唤醒一个线程，但是实质的给这个线程发放令牌,JVM看到后消耗这个令牌，然后唤醒那个线程
2.  然后park(),这时候发看到已经有通行证了，通行证数量设置为0，直接返回  
- 先park(),后unPark(Thread t)
1. 先park(),发现没有通行证，挂起
2. 然后unPark(Thread t),给改线程发放通行证，JVM通知那个线程有人给你发通行证了，你起来把，但是通行证需要回收，最后通行证是0  
