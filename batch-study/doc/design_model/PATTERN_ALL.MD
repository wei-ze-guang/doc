## 结构型模式（7 种）
关注类与类之间的结构关系，提高系统的灵活性和可复用性。  

| 模式                     | 场景     | 简述                            |
| ---------------------- | ------ |-------------------------------|
| ✅ **适配器模式**（Adapter）   | 接口不兼容  | 把一个接口转成目标接口（如充电头适配器） 和策略模式有点像 |
| ✅ **装饰器模式**（Decorator） | 动态增强功能 | 给对象动态地添加行为（如 IO 流、AOP）        |
| ✅ **代理模式**（Proxy）      | 控制访问   | 代表真实对象操作（如远程调用、权限校验）          |
| ✅ **外观模式**（Facade）     | 简化接口   | 提供统一接口调用多个子系统（如 Spring 外观类）   |
| ✅ **桥接模式**（Bridge）     | 多维度变化  | 把抽象和实现解耦（如消息通知：微信/邮件）         |
| ✅ **组合模式**（Composite）  | 树形结构   | 统一对待单个对象和组合对象（如菜单树、文件夹）       |
| ✅ **享元模式**（Flyweight）  | 减少对象数量 | 共用对象减少内存（如 String 常量池）        |
---  
## 行为型模式（11 种）
关注对象之间的交互和职责分配，提高系统的灵活性和扩展性。  

| 模式                                   | 场景      | 简述                        |
| ------------------------------------ | ------- | ------------------------- |
| ✅ **观察者模式**（Observer）                | 发布订阅    | 一改，全通知（如事件监听、MQ 订阅）       |
| ✅ **策略模式**（Strategy）                 | 可切换算法   | 封装多个策略互相替换（如支付方式、排序）      |
| ✅ **模板方法模式**（Template Method）        | 固定流程    | 父类定义算法结构，子类实现细节（如 JDBC）   |
| ✅ **责任链模式**（Chain of Responsibility） | 顺序处理请求  | 一条链逐个处理（如过滤器链、审批流）        |
| ✅ **命令模式**（Command）                  | 解耦请求和执行 | 把请求封装为对象（如按钮点击、事务回滚）      |
| ✅ **状态模式**（State）                    | 行为随状态切换 | 一个状态一个类（如订单状态：待支付→发货→完成）  |
| ✅ **中介者模式**（Mediator）                | 降低类之间耦合 | 通过中介统一调度（如聊天室）            |
| ✅ **迭代器模式**（Iterator）                | 遍历集合    | 统一遍历方式（如 List 的迭代器）       |
| ✅ **访问者模式**（Visitor）                 | 跨对象操作   | 给对象加新功能（如编译器、文件操作）        |
| ✅ **备忘录模式**（Memento）                 | 保存历史    | 保存对象快照，实现撤销/恢复（如 Ctrl+Z）  |
| ✅ **解释器模式**（Interpreter）             | 简易语言解释  | 自定义语言或规则解释（如正则表达式、SQL 解析） |
---    
##  一、创建型模式（5 种）

| 模式                             | 场景       | 简述                           |
| ------------------------------ | -------- | ---------------------------- |
| ✅ **单例模式**（Singleton）          | 控制全局唯一实例 | 一个类只创建一个对象，全局共用（如配置中心）       |
| ✅ **工厂方法模式**（Factory Method）   | 不知道用哪个子类 | 父类定义工厂接口，子类决定要创建哪种对象         |
| ✅ **抽象工厂模式**（Abstract Factory） | 多系列产品    | 创建一组相关的产品（UI组件/数据库连接等）       |
| ✅ **建造者模式**（Builder）           | 创建复杂对象   | 分步构建对象（如 StringBuilder、链式调用） |
| ✅ **原型模式**（Prototype）          | 大对象复制    | 通过克隆已有对象来创建新对象（如 clone()）    |
---  
## 初学者掌握一下几种
| 常用程度  | 模式名称                  |
| ----- | --------------------- |
| ★★★★★ | 单例、工厂、装饰器、策略、观察者、模板方法 |
| ★★★★☆ | 适配器、代理、责任链、状态模式       |
## 个人总既然
- 策略模式和适配器模式有点像，都有组合的  
  - 但是设配模式是为了实现同一个接口的功能，有不同的实现方式，但是功能一样
  - 适配模式一般是接口不同，有利用的关系  

## 类似或者区别
1. 单例 vs 工厂模式
- 相似点：
  - 都涉及到对象的创建。
  - 都是用来控制实例的生成，确保创建过程的一致性。
- 区别点：
  - 单例模式：确保类只有一个实例，并提供一个全局访问点。通常是用于那些需要共享资源或全局状态的场景。
  - 工厂模式：用于创建一组相关的对象，或者根据不同条件创建不同类型的对象。工厂模式关注如何生成不同的对象。
2. 装饰器 vs 代理模式
- 相似点：
  - 都是通过包装原始对象来增加新功能。
  - 都依赖于将原始对象封装起来，以增加新的行为。
- 区别点：
  - 装饰器模式：是对对象进行功能增强，装饰器通常是灵活的，可以动态地增加或修改行为。
  - 代理模式：用一个代理对象来控制对目标对象的访问，代理对象通常不增加目标对象的行为，而是控制访问（例如延迟加载、访问权限控制等）。
3. 策略 vs 状态模式
- 相似点：
  - 都涉及到将行为封装到独立的对象中，通过选择不同的策略或状态来改变对象的行为。
  - 都通过委托的方式来改变对象的行为。
- 区别点：
  - 策略模式：用来定义一组算法，并让客户端在运行时选择其中一种算法进行使用，算法通常是互相独立的。
  - 状态模式：状态模式关注的是对象的状态变化，不同的状态会触发不同的行为，状态之间是有转移的，通常与状态变化有关。
4. 模板方法 vs 责任链模式
- 相似点：
  - 都涉及到顺序执行多个操作步骤。
  - 都有控制流程的机制，并允许某些步骤可扩展。
- 区别点：
  - 模板方法模式：定义了算法的框架，某些步骤是固定的，某些步骤由子类实现。模板方法模式注重固定的流程结构，子类在模板方法中补充行为。
  - 责任链模式：多个处理对象形成链式结构，每个对象对请求进行处理或传递，直到有对象处理它。责任链模式更加灵活，处理过程没有固定顺序。
