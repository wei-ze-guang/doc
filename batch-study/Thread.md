### 监视器（Monitor）是什么？
#### 监视器（Monitor）其实就是一个对象的锁，记住是对象的，每个 Java 对象都有一个与之关联的“监视器锁”。
1. 当一个线程要执行同步代码块（synchronized）或者调用对象的wait()、notify()等方法时，必须先获得这个对象的监视器锁。  
2. 每个对象都有一个监视所，同一个类的不同对象他们各自有自己的监视器  
3. 不止对象，数组，object，字符串，集合都有，只要是对象都有



| 方法        | 属于哪个类               | 是静态方法吗   | 用法限制      | 常见用法举例                              |
| --------- | ------------------- | -------- | --------- | ----------------------------------- |
| `yield()` | `Thread` 类          | ✅ 静态方法   | 无         | `Thread.yield();`                   |
| `sleep()` | `Thread` 类          | ✅ 静态方法   | 必须捕获异常    | `Thread.sleep(1000);`               |
| `join()`  | `Thread` 类的**实例方法** | ❌ 不是静态方法 | 只能对线程对象使用 | `thread.join();`                    |
| `wait()`  | `Object` 类的**实例方法** | ❌ 不是静态方法 | 必须在同步块中使用 | `synchronized(obj) { obj.wait(); }` |
###  四个的区别
1. yield就是哪个线程里面写了这个东西,使用了这个方法的话，尝试让出CPU，是尝试，但是不一定成功，成功了之后他会还是  
处于就绪状态，等待调度，要是没成功他就继续执行他的线程，不让出CPU，这个也是不让出资源的 
2. sleep(1000)是类的静态方法，谁调用谁就睡眠，谁就是堵塞的，这里的堵塞是说这个线程在1000毫秒内不会执行，1000毫秒之后回到就绪状态，不让出资源的  
不一定1000毫秒后马上执行，要等到线程调度
3. join() 是实例的方法，哪个线程调用了t.join() ，哪个线程就会堵塞等待， 就是等到t线程完全执行完之后，程序才会继续执行下去，join(t) 最多等待t毫秒
4. wait，Object 家的，配合 synchronized 做沟通。其实他跟上面的几个没啥太大关系，wait是实例的方法，线程或者这个实例的监视器之后，调用了这个实例的  
wait方法，大概意思就是我愿意在这个实例上等到，等到某种情况我再继续走